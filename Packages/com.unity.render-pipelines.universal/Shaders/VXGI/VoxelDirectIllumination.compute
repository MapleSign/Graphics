#pragma kernel main

#pragma enable_d3d11_debug_symbols
#pragma multi_compile _ _DIRECTIONAL

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

Texture3D<unorm float4> _VoxelAlbedo;
SamplerState sampler_VoxelAlbedo;

RWTexture3D<unorm float4> _VoxelNormal;
RWTexture3D<unorm float4> _VoxelEmission;
RWTexture3D<half4> _VoxelRadiance;

float4 _VolumeMinPoint;
float4 _VolumeScale; // 1.0 / _VolumeSize
float4 _VolumeSize;
float4 _VolumeResolution; // res, res, 1.0 / res, 1.0 / res

float3 _LightPosWS;
half3 _LightColor;
half4 _LightAttenuation; // .xy are used by DistanceAttenuation - .zw are used by AngleAttenuation *for SpotLights)
half3 _LightDirection;   // directional/spotLights support
half4 _LightOcclusionProbInfo;
int _LightFlags;
int _ShadowLightIndex;
uint _LightLayerMask;
int _CookieLightIndex;

float TraceShadow(float3 posVS, float3 dir, float maxDist)
{
    float attenuation = 1.0;
    float step = _VolumeResolution.z;
    float3 samplePos = posVS + dir * step * 2.0;
    float t = 0.0;
    while (t < maxDist)
    {
        if ( any(samplePos < float3(0.0, 0.0, 0.0) || samplePos > float3(1.0, 1.0, 1.0)) )
        {
            break;
        }

        float4 sampleAlbedo = _VoxelAlbedo.SampleLevel(sampler_VoxelAlbedo, samplePos, 0);
        if (sampleAlbedo.a != 0.0)
        {
            attenuation = 0.0;
            break;
        }

        samplePos += dir * step;
        t += step;
    }

    return attenuation;
}

[numthreads(8, 8, 8)]
void main(uint3 tid : SV_DispatchThreadID)
{
    float4 albedo = _VoxelAlbedo[tid];
    if (albedo.a == 0.0)
    {
        return;
    }
    float4 normal = _VoxelNormal[tid];
    normal.xyz = normal.xyz * 2.0 - 1.0;
    float4 emission = _VoxelEmission[tid];

    float3 positionVS = float3(tid) * _VolumeResolution.z;
    float4 positionWS = float4(positionVS * _VolumeSize.xyz + _VolumeMinPoint.xyz, 1.0);
    Light light;
    float lightDistVS = 1.0;

    #if defined(_DIRECTIONAL)
        light.direction = _LightDirection;
        light.color = _LightColor.rgb;
        light.layerMask = _LightLayerMask;
        light.distanceAttenuation = 1.0;
        light.shadowAttenuation = 1.0;
    #else
        float3 lightVector = _LightPosWS - positionWS.xyz;
        float distanceSqr = max(dot(lightVector, lightVector), HALF_MIN);

        half3 lightDirection = half3(lightVector * rsqrt(distanceSqr));

        // full-float precision required on some platforms
        float attenuation = DistanceAttenuation(distanceSqr, _LightAttenuation.xy) * AngleAttenuation(_LightDirection.xyz, lightDirection, _LightAttenuation.zw);

        light.direction = lightDirection;
        light.color = _LightColor;

        light.distanceAttenuation = attenuation;
        light.shadowAttenuation = 1.0;

        light.layerMask = _LightLayerMask;

        float3 lightPosVS = (_LightPosWS - _VolumeMinPoint.xyz) * _VolumeScale.xyz;
        lightDistVS = length(lightPosVS - positionVS);
    #endif

    float shadow = TraceShadow(positionVS, light.direction, lightDistVS);

    float3 lightColor = light.color * light.distanceAttenuation * light.shadowAttenuation * shadow;
    // float NdotL = max(dot(normal.xyz, light.direction.xyz), 0.0);
    float NdotL = dot(normal.xyz * normal.xyz, abs(light.direction.xyz)); // normal weighted
    float3 brdf = albedo.rgb * INV_PI * NdotL;

    float3 radiance = _VoxelRadiance[tid].xyz;
    radiance += lightColor * brdf;
    radiance += emission.rgb;

    _VoxelRadiance[tid] = half4(radiance, 1.0);
}
